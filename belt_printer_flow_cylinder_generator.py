import tkinter as tk
from tkinter import simpledialog, messagebox, ttk
import os
import re
import math
import datetime

class GCodeGenerator:
    def __init__(self, base_gcode, layer_height, section_height, initial_flow_rate, bed_temp, nozzle_temp, 
                 flow_increase, num_sections, nozzle_diameter, cylinder_diameter, adhesion_offset):
        self.base_gcode = base_gcode
        self.layer_height = layer_height
        self.section_height = section_height
        self.initial_flow_rate = initial_flow_rate
        self.bed_temp = bed_temp
        self.nozzle_temp = nozzle_temp
        self.flow_increase = flow_increase
        self.num_sections = num_sections
        self.nozzle_diameter = nozzle_diameter
        self.adhesion_offset = adhesion_offset
        self.layer_heights = self.find_layer_heights()
        if len(self.layer_heights) >= 2:
            self.last_z = self.layer_heights[-1]
            self.second_last_z = self.layer_heights[-2]
        else:
            self.last_z = self.layer_heights[-1] if self.layer_heights else 0
            self.second_last_z = 0
        self.min_x, self.max_x, self.min_y, self.max_y = self.find_overall_bounding_box()
        self.center_x = (self.min_x + self.max_x) / 2
        self.center_y = (self.min_y + self.max_y) / 2
        self.max_diameter = min((self.max_x - self.min_x), (self.max_y - self.min_y))
        if cylinder_diameter > self.max_diameter:
            self.cylinder_diameter = self.max_diameter
        else:
            self.cylinder_diameter = cylinder_diameter
        self.cylinder_radius = self.cylinder_diameter / 2
        self.start_z = self.second_last_z + self.adhesion_offset
        self.print_end_sequence = self.extract_print_end_sequence()
    def find_layer_heights(self):
        z_heights = set()
        for line in self.base_gcode.splitlines():
            if line.startswith("G0 ") or line.startswith("G1 "):
                z_match = re.search(r'Z([0-9]+\.?[0-9]*)', line)
                if z_match:
                    z_heights.add(float(z_match.group(1)))
        return sorted(list(z_heights))

    def extract_print_end_sequence(self):
        print_end_sequence = ""
        print_end_found = False
        print_end_lines = []
        for line in self.base_gcode.splitlines():
            if "PRINT_END" in line or (print_end_found and not line.strip()):
                print_end_found = True
                print_end_lines.append(line)
        if print_end_lines:
            print_end_sequence = "\n".join(print_end_lines)
        return print_end_sequence
    
    def remove_print_end_sequence(self):
        if not self.print_end_sequence:
            return self.base_gcode
        base_without_end = self.base_gcode
        if self.print_end_sequence in base_without_end:
            base_without_end = base_without_end.replace(self.print_end_sequence, "")
        return base_without_end

    def find_overall_bounding_box(self):
        x_positions = []
        y_positions = []
        for line in self.base_gcode.splitlines():
            if line.startswith("G1 ") and "E" in line:
                x_match = re.search(r'X([0-9]+\.?[0-9]*)', line)
                y_match = re.search(r'Y([0-9]+\.?[0-9]*)', line)
                if x_match and y_match:
                    x_positions.append(float(x_match.group(1)))
                    y_positions.append(float(y_match.group(1)))
        if x_positions and y_positions:
            min_x = min(x_positions)
            max_x = max(x_positions)
            min_y = min(y_positions)
            max_y = max(y_positions)
            return min_x, max_x, min_y, max_y
        else:
            return 0, 100, 0, 100
    def get_last_position(self):
        x, y, z, e = None, None, None, None
        for line in self.base_gcode.splitlines():
            if line.startswith("G0 ") or line.startswith("G1 "):
                x_match = re.search(r'X([0-9]+\.?[0-9]*)', line)
                y_match = re.search(r'Y([0-9]+\.?[0-9]*)', line)
                z_match = re.search(r'Z([0-9]+\.?[0-9]*)', line)
                e_match = re.search(r'E([0-9]+\.?[0-9]*)', line)
                if x_match: x = float(x_match.group(1))
                if y_match: y = float(y_match.group(1))
                if z_match: z = float(z_match.group(1))
                if e_match: e = float(e_match.group(1))
        return x, y, z, e

    def generate_gcode(self):
        base_gcode_cleaned = self.remove_print_end_sequence().rstrip()
        continuation_gcode = "\n\n; CYLINDER CONTINUATION - SPIRAL VASE MODE\n"
        continuation_gcode += f"; Generated on: 2025-03-05 20:49:38\n"
        continuation_gcode += f"; Generated by: xboxhacker\n"
        continuation_gcode += f"; Starting Z: {self.start_z:.3f} mm (with {self.adhesion_offset:.3f}mm adhesion offset)\n"
        continuation_gcode += f"; Layer height: {self.layer_height} mm\n"
        continuation_gcode += f"; Section height: {self.section_height} mm\n"
        continuation_gcode += f"; Initial flow rate: {self.initial_flow_rate}%\n"
        continuation_gcode += f"; Bed temperature: {self.bed_temp}\n"
        continuation_gcode += f"; Nozzle temperature: {self.nozzle_temp}\n"
        continuation_gcode += f"; Flow increase per section: {self.flow_increase}%\n"
        continuation_gcode += f"; Number of sections: {self.num_sections}\n"
        continuation_gcode += f"; Nozzle diameter: {self.nozzle_diameter} mm\n"
        continuation_gcode += f"; Cylinder diameter: {self.cylinder_diameter} mm (max allowed: {self.max_diameter:.2f}mm)\n"
        continuation_gcode += f"; Print bounding box: X=[{self.min_x:.2f}, {self.max_x:.2f}], Y=[{self.min_y:.2f}, {self.max_y:.2f}]\n"
        continuation_gcode += f"; Cylinder center: X={self.center_x:.2f}, Y={self.center_y:.2f}\n\n"
        continuation_gcode += "G90 ; Absolute positioning\n"
        continuation_gcode += "M83 ; Relative extruder mode\n"
        continuation_gcode += f"M221 S{self.initial_flow_rate} ; Set initial flow rate to {self.initial_flow_rate}%\n"
        extrusion_width = self.nozzle_diameter * 1.2
        extrusion_height = self.layer_height
        extrusion_area = extrusion_width * extrusion_height
        filament_area = math.pi * ((1.75/2) ** 2)
        extrusion_ratio = extrusion_area / filament_area
        radius = self.cylinder_radius
        first_x = self.center_x + radius
        first_y = self.center_y
        continuation_gcode += f"; Moving to start position for cylinder perimeter\n"
        continuation_gcode += f"G0 F3000 X{first_x:.3f} Y{first_y:.3f} ; Move to first point\n"
        continuation_gcode += f"G1 F1200 Z{self.start_z:.3f} ; Move to start height with adhesion offset\n"
        continuation_gcode += f"G1 F300 E5.0 ; Prime extruder for good adhesion\n"
        continuation_gcode += f"; Printing first perimeter at Z={self.start_z:.3f} (with {self.adhesion_offset:.3f}mm adhesion offset)\n"
        segments = 72
        for i in range(1, segments + 1):
            angle = (i * 2 * math.pi / segments)
            x = self.center_x + radius * math.cos(angle)
            y = self.center_y + radius * math.sin(angle)
            prev_x = self.center_x + radius * math.cos((i-1) * 2 * math.pi / segments)
            prev_y = self.center_y + radius * math.sin((i-1) * 2 * math.pi / segments)
            segment_length = math.sqrt((x - prev_x)**2 + (y - prev_y)**2)
            extrusion = segment_length * extrusion_ratio * 1.3
            continuation_gcode += f"G1 F600 X{x:.3f} Y{y:.3f} E{extrusion:.4f}\n"
        continuation_gcode += f"\n; Beginning spiral climb from Z={self.start_z:.3f}\n"
        current_z = self.start_z
        target_z = self.start_z + (self.num_sections * self.section_height)
        current_section = 0
        current_flow_rate = self.initial_flow_rate
        z_per_segment = self.layer_height / segments
        steps = int(((target_z - self.start_z) / z_per_segment) + 1)
        for i in range(steps):
            angle = ((i % segments) * 2 * math.pi / segments)
            x = self.center_x + radius * math.cos(angle)
            y = self.center_y + radius * math.sin(angle)
            current_z += z_per_segment
            section = int((current_z - self.start_z) / self.section_height)
            if section > current_section:
                current_section = section
                current_flow_rate = self.initial_flow_rate + (section * self.flow_increase)
                continuation_gcode += f"; Starting section {section+1} with flow rate {current_flow_rate:.1f}%\n"
                continuation_gcode += f"M221 S{current_flow_rate:.1f} ; Set flow rate to {current_flow_rate:.1f}%\n"
            prev_angle = ((i-1) % segments * 2 * math.pi / segments)
            prev_x = self.center_x + radius * math.cos(prev_angle)
            prev_y = self.center_y + radius * math.sin(prev_angle)
            segment_length = math.sqrt((x - prev_x)**2 + (y - prev_y)**2 + z_per_segment**2)
            extrusion = segment_length * extrusion_ratio
            continuation_gcode += f"G1 X{x:.3f} Y{y:.3f} Z{current_z:.4f} E{extrusion:.4f} F800\n"
            if (i % segments) == 0 and i > 0:
                layer_num = int((current_z - self.start_z) / self.layer_height)
                continuation_gcode += f"; Layer {layer_num}, Z={current_z:.2f}\n"
            if current_z >= target_z:
                break
        continuation_gcode += "\n; End spiral vase cylinder\n"
        if self.print_end_sequence:
            continuation_gcode += "\n" + self.print_end_sequence + "\n"
        else:
            continuation_gcode += "M104 S0 ; Turn off extruder\n"
            continuation_gcode += "M140 S0 ; Turn off bed\n"
            continuation_gcode += "M107 ; Turn off fan\n"
            continuation_gcode += "M84 ; Disable motors\n"
        full_gcode = base_gcode_cleaned + continuation_gcode
        return full_gcode

def extract_settings_from_gcode(base_gcode):
    settings = {
        "layer_height": 0.2,
        "bed_temp": 60,
        "nozzle_temp": 210,
        "initial_flow_rate": 100,
        "section_height": 5.0,
        "flow_increase": 10,
        "nozzle_diameter": 0.4,
        "cylinder_diameter": 20.0
    }
    
    for line in base_gcode.splitlines():
        if ";HEIGHT-BELT:" in line:
            match = re.search(r';HEIGHT-BELT:\s*([0-9]+\.?[0-9]*)', line)
            if match:
                settings["layer_height"] = float(match.group(1))
        
        if "nozzle" in line.lower() and "diameter" in line.lower():
            match = re.search(r'([0-9]+\.?[0-9]*)\s*mm', line)
            if match:
                settings["nozzle_diameter"] = float(match.group(1))
                
        if "bed" in line.lower() and "temp" in line.lower():
            match = re.search(r'([0-9]+\.?[0-9]*)', line)
            if match:
                settings["bed_temp"] = int(float(match.group(1)))
                
        if "nozzle" in line.lower() and "temp" in line.lower() or "hotend" in line.lower():
            match = re.search(r'([0-9]+\.?[0-9]*)', line)
            if match:
                settings["nozzle_temp"] = int(float(match.group(1)))
                
        if line.startswith("M221 "):
            match = re.search(r'S([0-9]+\.?[0-9]*)', line)
            if match:
                settings["initial_flow_rate"] = int(float(match.group(1)))
    for line in base_gcode.splitlines():
        if line.startswith("M140"):
            match = re.search(r'S([0-9]+\.?[0-9]*)', line)
            if match:
                settings["bed_temp"] = int(float(match.group(1)))
        
        if line.startswith("M104") or line.startswith("M109"):
            match = re.search(r'S([0-9]+\.?[0-9]*)', line)
            if match:
                settings["nozzle_temp"] = int(float(match.group(1)))
                
        if line.startswith("M221"):
            match = re.search(r'S([0-9]+\.?[0-9]*)', line)
            if match:
                settings["initial_flow_rate"] = int(float(match.group(1)))
    
    return settings

def get_layer_heights(base_gcode):
    z_heights = set()
    for line in base_gcode.splitlines():
        if line.startswith("G0 ") or line.startswith("G1 "):
            z_match = re.search(r'Z([0-9]+\.?[0-9]*)', line)
            if z_match:
                z = float(z_match.group(1))
                z_heights.add(z)
    return sorted(list(z_heights))

def get_max_cylinder_diameter(base_gcode):
    x_positions = []
    y_positions = []
    for line in base_gcode.splitlines():
        if line.startswith("G1 ") and "E" in line:
            x_match = re.search(r'X([0-9]+\.?[0-9]*)', line)
            y_match = re.search(r'Y([0-9]+\.?[0-9]*)', line)
            if x_match and y_match:
                x_positions.append(float(x_match.group(1)))
                y_positions.append(float(y_match.group(1)))
    if x_positions and y_positions:
        min_x = min(x_positions)
        max_x = max(x_positions)
        min_y = min(y_positions)
        max_y = max(y_positions)
        max_diameter = min(max_x - min_x, max_y - min_y)
        return max_diameter
    else:
        return 20.0
def create_gcode_file(base_gcode, layer_height, section_height, initial_flow_rate, bed_temp, nozzle_temp, 
                     flow_increase, num_sections, nozzle_diameter, cylinder_diameter, adhesion_offset):
    try:
        max_diameter = get_max_cylinder_diameter(base_gcode)
        if cylinder_diameter > max_diameter:
            if messagebox.askyesno("Warning", 
                           f"Cylinder diameter {cylinder_diameter}mm is larger than the maximum allowed ({max_diameter:.2f}mm) based on print size.\n\n"
                           f"Would you like to use the maximum allowed diameter instead?"):
                cylinder_diameter = max_diameter
            else:
                messagebox.showinfo("Process Cancelled", "G-code generation cancelled.")
                return False
        
        generator = GCodeGenerator(base_gcode, layer_height, section_height, initial_flow_rate, bed_temp, 
                                  nozzle_temp, flow_increase, num_sections, nozzle_diameter, cylinder_diameter,
                                  adhesion_offset)
        gcode = generator.generate_gcode()
        output_path = os.path.join(os.path.dirname(os.path.abspath(__file__)), "output.gcode")
        with open(output_path, "w") as file:
            file.write(gcode)
        print(f"G-code file generated successfully at: {output_path}")
        print(f"File size: {os.path.getsize(output_path)/1024:.1f} KB")
        messagebox.showinfo("Success", f"G-code file generated successfully!\nLocation: {output_path}")
        return True
    except Exception as e:
        print(f"Error generating G-code: {e}")
        messagebox.showerror("Error", f"Error generating G-code: {e}")
        return False
def main():
    try:
        root = tk.Tk()
        root.title("Belt Printer Flow Cylinder Generator")
        root.geometry("500x550")
        main_frame = ttk.Frame(root, padding="20")
        main_frame.pack(fill=tk.BOTH, expand=True)
        
        try:
            base_gcode_path = os.path.join(os.path.dirname(os.path.abspath(__file__)), "base.gcode")
            if not os.path.exists(base_gcode_path):
                raise FileNotFoundError("base.gcode file not found in the script directory.")

            with open(base_gcode_path, "r") as file:
                base_gcode = file.read()
                
            settings = extract_settings_from_gcode(base_gcode)
            layer_heights = get_layer_heights(base_gcode)
            if len(layer_heights) >= 2:
                second_last_z = layer_heights[-2]
            else:
                second_last_z = 0
                
            max_diameter = get_max_cylinder_diameter(base_gcode)
            if max_diameter < settings["cylinder_diameter"]:
                settings["cylinder_diameter"] = max_diameter
                
        except Exception as e:
            print(f"Error loading base.gcode: {e}")
            messagebox.showerror("Error", f"Error loading base.gcode: {e}")
            return
        
        ttk.Label(main_frame, text="G-Code Parameters", font=("Arial", 14, "bold")).grid(row=0, column=0, columnspan=2, pady=(0, 15), sticky="w")
        
        row = 1
        ttk.Label(main_frame, text="Cylinder Start Z:", font=("Arial", 10, "bold")).grid(row=row, column=0, sticky="w")
        ttk.Label(main_frame, text=f"{second_last_z:.3f} mm", foreground="#009900").grid(row=row, column=1, pady=5, padx=10, sticky="w")
        
        row += 1
        ttk.Separator(main_frame, orient='horizontal').grid(row=row, column=0, columnspan=2, sticky="ew", pady=10)
        
        row += 1
        ttk.Label(main_frame, text="Layer Height (mm):").grid(row=row, column=0, sticky="w")
        layer_height_var = tk.DoubleVar(value=settings["layer_height"])
        ttk.Entry(main_frame, textvariable=layer_height_var, width=10).grid(row=row, column=1, pady=5, padx=10, sticky="w")
        
        row += 1
        ttk.Label(main_frame, text="Nozzle Diameter (mm):").grid(row=row, column=0, sticky="w")
        nozzle_diameter_var = tk.DoubleVar(value=settings["nozzle_diameter"])
        ttk.Entry(main_frame, textvariable=nozzle_diameter_var, width=10).grid(row=row, column=1, pady=5, padx=10, sticky="w")
        
        row += 1
        ttk.Label(main_frame, text="Bed Temperature (°C):").grid(row=row, column=0, sticky="w")
        bed_temp_var = tk.IntVar(value=settings["bed_temp"])
        ttk.Entry(main_frame, textvariable=bed_temp_var, width=10).grid(row=row, column=1, pady=5, padx=10, sticky="w")
        
        row += 1
        ttk.Label(main_frame, text="Nozzle Temperature (°C):").grid(row=row, column=0, sticky="w")
        nozzle_temp_var = tk.IntVar(value=settings["nozzle_temp"])
        ttk.Entry(main_frame, textvariable=nozzle_temp_var, width=10).grid(row=row, column=1, pady=5, padx=10, sticky="w")
        
        row += 1
        ttk.Label(main_frame, text="Adhesion Offset (mm):").grid(row=row, column=0, sticky="w")
        adhesion_offset_var = tk.DoubleVar(value=-0.5 * settings["layer_height"])
        adhesion_offset_entry = ttk.Entry(main_frame, textvariable=adhesion_offset_var, width=10)
        adhesion_offset_entry.grid(row=row, column=1, pady=5, padx=10, sticky="w")
        ttk.Label(main_frame, text="(Negative value to drop into previous layer)", foreground="gray", font=("Arial", 8)).grid(row=row, column=1, pady=(0, 2), padx=(100, 0), sticky="w")
        
        row += 1
        ttk.Label(main_frame, text="Initial Flow Rate (%):").grid(row=row, column=0, sticky="w")
        initial_flow_rate_var = tk.IntVar(value=settings["initial_flow_rate"])
        ttk.Entry(main_frame, textvariable=initial_flow_rate_var, width=10).grid(row=row, column=1, pady=5, padx=10, sticky="w")
        row += 1
        ttk.Label(main_frame, text="Section Height (mm):").grid(row=row, column=0, sticky="w")
        section_height_var = tk.DoubleVar(value=settings["section_height"])
        ttk.Entry(main_frame, textvariable=section_height_var, width=10).grid(row=row, column=1, pady=5, padx=10, sticky="w")
        
        row += 1
        ttk.Label(main_frame, text="Flow Increase per Section (%):").grid(row=row, column=0, sticky="w")
        flow_increase_var = tk.IntVar(value=settings["flow_increase"])
        ttk.Entry(main_frame, textvariable=flow_increase_var, width=10).grid(row=row, column=1, pady=5, padx=10, sticky="w")
        
        row += 1
        ttk.Label(main_frame, text="Number of Sections:").grid(row=row, column=0, sticky="w")
        num_sections_var = tk.IntVar(value=5)
        ttk.Entry(main_frame, textvariable=num_sections_var, width=10).grid(row=row, column=1, pady=5, padx=10, sticky="w")
        
        row += 1
        ttk.Label(main_frame, text="Cylinder Diameter (mm):").grid(row=row, column=0, sticky="w")
        cylinder_diameter_var = tk.DoubleVar(value=settings["cylinder_diameter"])
        ttk.Entry(main_frame, textvariable=cylinder_diameter_var, width=10).grid(row=row, column=1, pady=5, padx=10, sticky="w")
        ttk.Label(main_frame, text=f"(max allowed: {max_diameter:.1f}mm)", foreground="gray", font=("Arial", 8)).grid(row=row, column=1, pady=(0, 2), padx=(100, 0), sticky="w")
        
        # Add some spacing
        row += 1
        ttk.Frame(main_frame).grid(row=row, column=0, pady=5)
        # Add generate button
        row += 1
        generate_button = ttk.Button(main_frame, text="Generate G-Code",
                                    command=lambda: create_gcode_file(
                                        base_gcode,
                                        layer_height_var.get(),
                                        section_height_var.get(),
                                        initial_flow_rate_var.get(),
                                        bed_temp_var.get(),
                                        nozzle_temp_var.get(),
                                        flow_increase_var.get(),
                                        num_sections_var.get(),
                                        nozzle_diameter_var.get(),
                                        cylinder_diameter_var.get(),
                                        adhesion_offset_var.get()
                                    ))
        generate_button.grid(row=row, column=0, columnspan=2, pady=15)
        
        # Add status message at bottom of window
        row += 1
        status_label = ttk.Label(main_frame, text="Ready. Place base.gcode in the same folder as this script.", font=("Arial", 8), foreground="gray")
        status_label.grid(row=row, column=0, columnspan=2, pady=(5, 0), sticky="w")
        
        # Add timestamp
        row += 1
        timestamp_label = ttk.Label(main_frame, text=f"Last updated: 2025-03-05 20:54:51 by xboxhacker", font=("Arial", 8), foreground="gray")
        timestamp_label.grid(row=row, column=0, columnspan=2, sticky="w")
        
        # Center the window
        root.update_idletasks()
        width = root.winfo_width()
        height = root.winfo_height()
        x = (root.winfo_screenwidth() // 2) - (width // 2)
        y = (root.winfo_screenheight() // 2) - (height // 2)
        root.geometry('{}x{}+{}+{}'.format(width, height, x, y))
        
        root.mainloop()
    except Exception as e:
        print(f"Error in main UI: {e}")
        messagebox.showerror("Error", f"Error in application: {e}")
        
if __name__ == "__main__":
    main()
